1. 每个Raft实例的状态（log，状态机等）会被并发的Goroutine的事件响应所影响，所以这些状态可以用**共享数据和锁**来并发更新
2. 对于两个时间驱动的时间，分别都需要一个goroutine来响应
3. 选举超时的实现：在Raft结构中维护一个变量，包含着上次听到领导者消息的时间，然后使用**time.Sleep**来定期检查
4. 每一个Raft应该有一个**commitIndex**变量，它来表示是否有已提交的日志，如果有，则会使用**Applych**这个通道发送数据到状态机，更新状态机。这个过程通常使用单个Goroutine和sync.Cond条件变量来实现，以确保适当时候唤醒goroutine和数据的顺序性。
5. 日志匹配特性:即如果两个日志条目具有相同的索引和任期号，那么它们之前的所有日志条目也必须相同。通过在AppendEntries中包含prevLogIndex和prevLogTerm，领导者可以确保跟随者的日志与自己的日志在prevLogIndex之前的部分是一致的。
6. 每次RPC数据发送和接收处理，都应该有自己的Goroutine
7. 领导者在处理回复时必须小心；它必须检查自发送 RPC 以来任期是否已更改，并且必须考虑到来自并发 RPC 的回复可能已更改领导者状态的可能性
8. 更改commit的时候，如果log的term不等于现在节点的term，则无法提交这个新的log。 只能提交最新的log的时候**顺便**提交前面的log
-----
# 关于使用锁的建议
1. 每当你有多个 goroutine 使用的数据，并且至少有一个 goroutine 可能会修改这些数据时，goroutine 应该使用锁来防止数据的同时使用。
2. 我们需要在整个更新序列中持续持有锁。所有其他使用 rf.currentTerm 或 rf.state 的代码也必须持有锁，以确保所有使用的独占访问。
3. 此外，currentTerm 的每一次使用都必须持有锁，以确保没有其他 goroutine 在我们的临界区中修改 currentTerm。
4. 通常在执行任何可能等待的操作时持有锁是一个坏主意：读取 Go 通道、发送通道、等待计时器、调用 time.Sleep() 或发送 RPC（并等待回复）。**避免死锁：占有等待** 等待的代码应该首先释放锁。如果这不太方便，有时创建一个单独的 goroutine 来执行等待是有用的。
5. 