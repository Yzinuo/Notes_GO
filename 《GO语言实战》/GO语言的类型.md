# 用户自定义的类型
==任何时候，创建一个变量并初始化为其零值，习惯是使用var关键字==

结构体定义的时候，属性之间不需要添加逗号。

`type Duration int64` int64是基础类型。
在C中这是取别名。但是在GO中不是如此，go语言会把他们看作两个独立的类型，虽然底层基本一样。且Go中，编译器不会对不同的类型进行隐式转换。

---

# 方法
方法本身也就是是个函数，只不过声明的时候func 和 函数名之间有一个参数（接收者），这代表这这个方法属于哪一个实体。

## 值接受者和指针接受者
如果是值接收者，调用时会使用这个值的副本来执行这个方法。方法会得到一个副本。指针接受者会使用实际值来调用方法。

GO编译器背后会当需要时，把指针解引用成值，把值取地址为指针。==但是只针对于变量而言==

---

# 接口 
如果用户定义的类型实现了某个接口类型声明的方法，那么这个用户定义的类型的值就可以赋值给这个接口类型。这个赋值会把用户定义的类型的值存入接口类型的值。

接口值是一个包含两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表较iTable，包含了存储的值的类型信息和它方法集。第二个字是指向所存储值的指针。


==当是自定义类型的指针接受者实现了这个接口，我们在使用参数为这个接口的函数时，输入值是不对的，因为这个值的指针才算是接口==

**用指针接受者来实现接口时该类型的值不算实现了这个接口**

## 方法集
如果使用指针接受者来实现一个接口，那么只有指向那个类型的指针才能实现对应的接口。如果使用值接受者实现该接口，那么那个类型的值和指针都能实现对应的接口。

因为编译器不是总能成功获得值的地址，所以规定类型为值的对象，只能调用接受值为值的方法。而指针可以调用接受值为值和指针的方法。  

从接受值的方法角度来看，当接受值为值的方法，可以被指针对象和值对象调用。而接受值为指针的只能由指针对象调用。


这也是用指针接受者来实现接口时该类型的值不算实现了这个接口的原因

**但是对于变量就没有那么多限制，因为编译器会对变量进行转换**

```
bill := user{"BILL","Bill@email.com"}
bill.changeEmail  // successful


bill := user{"BILL","Bill@email.com"}.changeEmail  //default
```

# 嵌入类型（类似继承）
嵌入类型是将已有的类型直接声明在新的结构类型里面，被嵌入的类型被称之为新的外部类型的内部类型。

通过嵌入类型，与内部类型相关的标识符（属性和方法）算是外部类型的一部分。外部类型也可以通过声明和内部类型标识符同名的标识符来覆盖内部标识符的字段或方法。（重写）

==要嵌入一个类型只需要声明这个类型的名字就可以了，注意与其他字段和嵌入字段的语法不同==

由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型对接口的实现，外部类型也同样实现了这个接口。

如若我们不想要这个实现，怎么办？
- 我们直接为外部类型实现这个接口，内部类型的接口就不会被提上来，但是我们还可以通过调用内部类型去使用内部接口： ad.user.notify()
- 内部类型的值一直都在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型的实现方法。
  
  # 公开或未公开的标识符
  小写字母开头是未公开，大写字母开头是公开。

  工厂函数：生成新对象的函数，在GO中习惯命名为new。

  - 标识符（函数或变量名字）才有公开和未公开的属性，值没有
  - 短变量声明操作符，有能力捕捉并且创建一个未公开的类型的变量。
 
 公开结构类型中未公开的字段也会显示未公开，不能在本包外被访问。

 公开和未公开可以和嵌入一起使用：
 我们希望组织程序员复制这个类型，我们就可以通过对该类型添加一个指向未公开的类型，这层内嵌阻止了赋值。

 
